# App shell

Le terme "app shell" fait référence à une approche architecturale utilisée dans le développement d'applications web qui sépare l'infrastructure et l'interface utilisateur de l'application principale des données. L'app shell consiste généralement en un minimum de HTML, CSS et JavaScript nécessaires au rendu de l'interface utilisateur de l'application.

Dans O3, l'app shell fait référence au code contenu dans le paquetage `esm-app-shell`. Il gère tout depuis le moment où vous demandez une page jusqu'au moment où vous voyez le rendu de l'interface utilisateur. Le premier port d'appel à l'app-shell est le fichier `index.ejs`. Ce fichier est le point d'entrée de l'application et est responsable du rendu de l'app shell. O3 est une application à page unique basée sur un seul fichier HTML qui est généré à partir du fichier modèle `index.ejs`. Le modèle `index.ejs` est principalement du HTML statique avec quelques valeurs dynamiques qui sont interpolées dans le modèle au moment de la construction. Nous passons des choses comme:

- La locale par défaut.
- Le titre de la page.
- Le favicon de l'application.
- Une balise `<link>` qui est une référence à la carte d'importation.
- Une balise `<script>` pour la carte d'importation.
- Une balise `<link>` qui est une référence à un registre de toutes les pages et extensions agrégées à partir de tous les modules frontaux.
- Une balise `<script>` pour le registre des routes.

Le template contient aussi une référence à `openmrs.js`, le fichier principal généré par le bundle Webpack. Il crée une fonction `initializeSpa` et l’attache à l’objet `window`, la rendant disponible dans le scope global. Cette fonction est appelée depuis le template `index.ejs` et s’occupe d’initialiser l’application. Le template inclut aussi :

- `<div>`s where containers for modals, inline notifications, toast notifications get rendered in the UI.
- A loading spinner that gets rendered when frontend modules are getting loaded by the app shell.
- An error state that gets rendered when the application fails to load.

## initializeSpa

La fonction `initializeSpa` :

- Appends some useful global variables to the window object, e.g. `openmrsSpaBase`, `spaBase`, `spaBasePath` and `spaVersion`.
- Initializes the module loading mechanism by invoking the `run` function.

### run()

La fonction `run` est responsable de :

- Afficher le spinner de chargement. Ce spinner s’affiche jusqu’à ce que les modules aient fini de se charger.
- Setting up breakpoints in the UI for `tablet`, `small-desktop` and `large-desktop` viewports.
- Connecter les abonnements aux endroits appropriés dans le shell de l'application pour les toasts, les notifications en ligne et les modals.
- Appeler `setupApiModule` pour initialiser le schéma de configuration.
- Appeler `registerCoreExtensions` qui implémente la fonctionnalité de breadcrumbs.
- Appeler `setupApps`, qui gère réellement le chargement des modules.

### setupApps()

La fonction `setupApps` charge toutes les routes depuis le registre des routes puis invoque `registerApp()` pour chaque module et sa définition (dépendances backend, pages et extensions qu’il fournit). `registerApp()` :

- Enregistre un schéma de configuration implicite pour l’application.
- Parcourt les extensions et les enregistre dans le registre des extensions.
- Ajoute les pages à une variable globale, où elles sont ordonnées via la propriété `order`, qui détermine l’ordre de rendu dans le DOM. Nous créons un `<div>` pour chaque page et l’ajoutons au DOM. Cela garantit que l’ordre du DOM correspond à l’ordre des pages. Par exemple, la barre de navigation doit être rendue en premier, donc elle a un ordre de 0. Cela se fait dans la fonction `finishRenderingAllApps`, appelée après le chargement de tous les modules frontaux.

Les pages et les extensions sont implémentées comme des objets Single‑spa, qui sont essentiellement des objets JavaScript définissant trois fonctions de cycle de vie :

- `bootstrap` - Cette fonction est appelée une seule fois lors du premier chargement de l’application. Elle est responsable du chargement des dépendances nécessaires.
- `mount` - Cette fonction est appelée lorsque la page est chargée pour la première fois. Elle est responsable du rendu de la page. Sous le capot, elle appelle typiquement `ReactDOM.createRoot()` et rend l'arbre React dans l'élément DOM qui correspond à la page.
- `unmount` - Cette fonction est appelée lorsque la page est déchargée. Elle est responsable du nettoyage des ressources utilisées par la page.

Les pages et les extensions utilisent la fonction `getLoader()` qui prend la définition de la page ou de l'extension et renvoie une fonction qui peut être utilisée pour charger la page ou l'extension. Si vous regardez le point d'entrée d'un module frontend (`src/index.ts`), vous verrez des exportations nommées qui invoquent la fonction `getAsyncLifecycle` ou `getSyncLifecycle`. Ces fonctions nous permettent d'envelopper les pages et les extensions dans un format qui peut être chargé par la bibliothèque React. Essentiellement, le composant React est enveloppé dans un `openmrsComponentDecorator` qui nous permet au framework de:

- Gérer les erreurs si le rendu échoue de manière catastrophique.
- Mettre en place un support de configuration pour le composant.
- Mettre en place le support `i18n` pour le composant.
- Mettre en place un système de suspension pour le composant qui prend par défaut la valeur `null`.
- Rendre le composant.

Quand vous définissez une `page`, sa définition peut inclure une propriété `route` ou `routeRegex`. Single‑spa utilise l’emplacement indiqué par `route` ou `routeRegex` pour déterminer quelles pages rendre à cet endroit via la fonction `getActivityFn`. Dans O3, les pages sont essentiellement des applications single‑spa rendues dans un `<div>` prédéterminé. Les extensions utilisent le concept de `parcel` de single‑spa : elles ont les mêmes cycles de vie que les applications single‑spa, sauf qu’elles n’ont pas de `getActivityFn`. Cela signifie que single‑spa ne montera ou ne démontera jamais un parcel automatiquement. À la place, il faut lui indiquer manuellement quand monter ou démonter un parcel. Le système d’extensions existe pour déterminer quand une extension doit être chargée (et donc appeler `mount`) et déchargée (et donc appeler `unmount`). Chaque extension est montée via le composant `Extension` défini dans le framework. Ce composant rend l’extension (en appelant `mount`) et démonte le parcel quand il est démonté. Il définit un `<div>` avec un attribut `data-extension-id` dans lequel React rend le parcel. Le point clé : une fois que les `<div>` sont créés pour les pages et extensions, React prend le relais et rend le contenu dans le DOM.

## Chargement des modules

O3 charge les modules frontaux via les import maps SystemJS et la fédération de modules. L’app shell injecte une
`systemjs-importmap` dans `index.ejs`, précharge la carte d’importation, puis l’utilise pour résoudre les URLs des
modules.

La plupart des modules sont construits comme des bundles de fédération de modules. Pour chaque URL, l’app shell ajoute
une balise `<script>`. Quand le script est chargé, il expose un conteneur Webpack (`init`/`get`) que l’app shell utilise
pour obtenir les exports du module.

Certains modules historiques ne sont pas des bundles de fédération de modules ; dans ce cas, l’app shell les charge comme
des modules SystemJS via la carte d’importation.
