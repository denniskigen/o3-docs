import { Callout } from "nextra-theme-docs";

# R√©cup√©ration des donn√©es

- Colocalisez votre logique de r√©cup√©ration de donn√©es dans un fichier suffix√© avec `.resource`. Par exemple, `user.resource.ts` contient la logique de r√©cup√©ration de donn√©es pour le composant User.
- Dans la mesure du possible, pr√©f√©rez abstraire votre r√©cup√©ration de donn√©es dans un hook personnalis√© plut√¥t que de [r√©cup√©rer avec des effets](https://react.dev/reference/react/useEffect#fetching-data-with-effects). La r√©cup√©ration de donn√©es avec des effets pr√©sente de nombreux [inconv√©nients](https://react.dev/reference/react/useEffect#fetching-data-with-effects) et doit √™tre √©vit√©e. Pr√©f√©rez plut√¥t l'utilisation de hooks [SWR](https://swr.vercel.app/).
- Utilisez les hooks [SWR](https://swr.vercel.app/) pour r√©cup√©rer les donn√©es du backend. Utilisez [useSWRImmutable](https://swr.vercel.app/docs/revalidation.en-US#disable-automatic-revalidations) pour les ressources qui ne sont pas cens√©es changer souvent, telles que les concepts ou les configurations backend. Alternativement, vous pouvez utiliser [useOpenmrsSWR](https://github.com/openmrs/openmrs-esm-core/blob/main/packages/framework/esm-react-utils/src/useOpenmrsSWR.ts) qui est un wrapper autour de `useSWR` qui g√®re automatiquement les contr√¥leurs d'abandon et s'int√®gre avec `openmrsFetch`.
- Placez le hook SWR dans un fichier de ressource et exportez-le en tant que fonction. Cela nous permet de r√©utiliser le m√™me hook dans plusieurs composants.
- M√©morisez la valeur de retour de votre hook SWR en utilisant `useMemo` pour √©viter des rerenders inutiles. Ceci est particuli√®rement important si le hook est utilis√© dans un composant qui est rendu plusieurs fois, comme une ligne de tableau. Lors de la cr√©ation de hooks personnalis√©s qui encapsulent SWR, m√©morisez toujours l'objet de retour :

  ```tsx
  // Bon - valeur de retour m√©moris√©e
  export function usePatient(patientUuid?: string) {
    const { data: patient, error, isValidating } = useSWR(...);
    
    return useMemo(
      () => ({
        isLoading: isValidating && !error && !patient,
        patient,
        patientUuid,
        error,
      }),
      [isValidating, error, patient, patientUuid],
    );
  }
  ```
- Les hooks de r√©cup√©ration de donn√©es doivent suivre la convention de nommage `use<resource>`. Par exemple, `useUser` est le hook pour r√©cup√©rer les donn√©es utilisateur.
- Utilisez [openmrsFetch](https://github.com/openmrs/openmrs-esm-core/blob/main/packages/framework/esm-api/src/openmrs-fetch.ts) pour r√©cup√©rer les donn√©es du backend. `openmrsFetch` est un wrapper autour de l'API `fetch` qui ajoute des en-t√™tes d'authentification et d'autorisation et g√®re les erreurs. Passez-le aux hooks SWR comme argument `fetcher`.
- Utilisez les propri√©t√©s `error`, `isLoading`, `isValidating` et `mutate` du hook SWR pour g√©rer les erreurs, les √©tats de chargement et les mutations. Ne recr√©ez pas ces propri√©t√©s manuellement.
- Utilisez le mod√®le de [r√©cup√©ration conditionnelle de donn√©es de SWR](https://swr.vercel.app/docs/conditional-fetching) lorsque la requ√™te d√©pend d'une condition. Par exemple, si la requ√™te d√©pend d'une prop, ne faites la requ√™te que si la prop est vraie.

  ```tsx
  // Ne r√©cup√©rer les donn√©es utilisateur que si userId est fourni
  const url = userId ? `/ws/rest/v1/user/${userId}` : null;
  const { data, error, isLoading, isValidating, mutate } = useSWR<User>(url, openmrsFetch);
  ```

## Contrats : rendre les √©tats explicites

Les hooks de r√©cup√©ration de donn√©es doivent rendre les √©tats de chargement, d'erreur et de succ√®s explicites et faciles √† g√©rer.

- Ne retournez pas "peut-√™tre des donn√©es" sans retourner les indicateurs d'√©tat SWR associ√©s.
- Les composants consommant les hooks doivent g√©rer :
  - le chargement (`isLoading` / `isValidating`),
  - l'erreur (`error`),
  - le succ√®s vide (charg√© mais aucun r√©sultat).

Cela emp√™che les bugs d'"hypoth√®ses implicites" (par exemple, le rendu avec des donn√©es non d√©finies).

<Callout emoji="‚ö†Ô∏è" type="warning">
  **Rendre les invariants visibles** : Toujours retourner une forme coh√©rente avec `{ data, error, isLoading }` et exiger que l'interface utilisateur g√®re explicitement les trois √©tats.
</Callout>

  ```tsx
  // Bon - gestion explicite des √©tats
  const { data, error, isLoading } = usePatient(patientUuid);
  
  if (isLoading) {
    return <InlineLoading />;
  }

  if (error) {
    return <ErrorState error={error} />;
  }

  if (!data) {
    return <EmptyState />;
  }
   
  return <PatientBanner patient={data} />;
  ```

## Comportement born√© : √©viter les nouvelles tentatives/polling non born√©s

Les nouvelles tentatives et les boucles de rafra√Æchissement non born√©es causent une latence et une charge impr√©visibles.

- Les nouvelles tentatives doivent √™tre born√©es et intentionnelles :
  - Pas de nouvelles tentatives infinies
  - Nouvelle tentative uniquement sur les √©checs transitoires
- Le polling/rafra√Æchissement doit √™tre born√© :
  - Pr√©f√©rez la revalidation sur focus / reconnexion lorsque c'est appropri√©
  - Si le polling est requis, d√©finissez un intervalle explicite et documentez pourquoi

<Callout emoji="üîí" type="warning">
  **Comportement born√©** : Politique de nouvelle tentative standard (nombre max de tentatives, backoff, quand *ne pas* r√©essayer), limites de polling, valeurs par d√©faut de pagination.
</Callout>

  ```tsx
  // Bon - politique de nouvelle tentative explicite
  const { data } = useSWR(url, fetcher, {
    errorRetryCount: 3,
    errorRetryInterval: 1000,
    revalidateOnFocus: true,
    revalidateOnReconnect: true,
    refreshInterval: 0, // D√©sactiver explicitement le polling
  });
  ```

## Pr√©f√©rer les hooks √©troits aux hooks g√©n√©riques

Concevez les hooks pour qu'ils soient difficiles √† utiliser incorrectement :

- Pr√©f√©rez les hooks sp√©cifiques √† une ressource (`usePatientVisits(patientUuid)`) aux hooks "faire n'importe quoi".
- Pr√©f√©rez des param√®tres typ√©s et contraints aux sacs d'options qui permettent des combinaisons invalides.

<Callout emoji="üéØ" type="info">
  **Concevoir les API pour les mauvais usages** : D√©courager le "hook de r√©cup√©ration g√©n√©rique qui fait n'importe quoi" ; pr√©f√©rer les hooks sp√©cifiques √† une ressource avec des param√®tres √©troits.
</Callout>

  ```tsx
  // Bon - hook √©troit et sp√©cifique
  export function usePatientVisits(patientUuid: string) {
    const url = patientUuid ? `/ws/rest/v1/visit?patient=${patientUuid}` : null;
    const { data, error, isLoading } = useSWR(url, openmrsFetch);
    return {
      visits: data ?? [],
      error,
      isLoading
    }
  }

  // √Ä √©viter - trop g√©n√©rique, facile √† mal utiliser
  export function useGenericFetch(url: string, options?: any) {
    return useSWR(url, options?.fetcher, options);
  }
  ```

## Observabilit√© : inclure le contexte avec les √©checs

Lors de l'exposition des erreurs :

- Conservez l'objet d'erreur original.
- Attachez suffisamment de contexte pour d√©boguer (nom de la ressource + entr√©es cl√©s, pas de secrets).
- Assurez-vous que l'interface utilisateur affiche des √©tats d'erreur significatifs ; √©vitez le repli silencieux vers une interface utilisateur vide.

<Callout emoji="üîç" type="info">
  **Observabilit√©** : Exiger des erreurs contextuelles (point de terminaison + param√®tres + ID de corr√©lation si disponible) et une interface utilisateur d'erreur coh√©rente pour l'utilisateur.
</Callout>

  ```tsx
  // Bon - l'erreur inclut le contexte
  if (error) {
    console.error('√âchec de la r√©cup√©ration des visites du patient', {
      patientUuid,
      endpoint: '/ws/rest/v1/visit',
      error: error.message,
    });
    
    return (
      <ErrorState
        error={error}
        headerTitle={t('errorLoadingVisits', 'Erreur lors du chargement des visites')}
      />
    );
  }
  ```

## Valeurs par d√©faut (recommand√©es)

Si un hook choisit un comportement SWR non par d√©faut, il doit √™tre explicite dans le hook :

- Politique de nouvelle tentative (nombre + conditions)
- Strat√©gie de rafra√Æchissement (focus/reconnexion/polling)
- Strat√©gie de d√©duplication/stale

Ces d√©cisions appartiennent au hook (la limite de ressource), pas dispers√©es dans les composants.

<Callout emoji="‚öôÔ∏è" type="info">
  **Valeurs par d√©faut** : Le d√©lai d'attente, le nombre de tentatives, l'intervalle de d√©duplication, la strat√©gie stale et la politique de pagination doivent √™tre explicites dans les hooks.
</Callout>

  ```tsx
  // Bon - les valeurs par d√©faut sont explicites dans le hook
  export function usePatientVisits(patientUuid: string) {
    const url = patientUuid ? `/ws/rest/v1/visit?patient=${patientUuid}` : null;
    
    return useSWR(url, openmrsFetch, {
      // Politique de nouvelle tentative explicite
      errorRetryCount: 3,
      errorRetryInterval: 1000,
      
      // Strat√©gie de rafra√Æchissement explicite
      revalidateOnFocus: false, // Les visites ne changent pas fr√©quemment
      revalidateOnReconnect: true,
      refreshInterval: 0, // Pas de polling
    });
  }
  ```

- Filtrez les donn√©es invalides (null, undefined ou enregistrements incomplets) au niveau du hook plut√¥t que dans les composants. Cela garantit que tous les consommateurs re√ßoivent des donn√©es propres et valides et emp√™che les erreurs lors de l'acc√®s aux propri√©t√©s imbriqu√©es :

  ```tsx
  // Bon - filtrage au niveau du hook
  export function usePatients(patientUuids: string[]) {
    const { data, error, isLoading } = useSWR(...);
    
    const validPatients = useMemo(
      () => data?.filter((patient): patient is Patient => 
        patient !== null && patient.person !== null
      ) ?? null,
      [data]
    );
    
    return { data: validPatients, error, isLoading };
  }
  ```

- Lors de l'utilisation de repr√©sentations personnalis√©es dans les appels API, d√©finissez-les comme constantes au niveau du module pour la r√©utilisabilit√© :

  ```tsx
  // Bon - repr√©sentation personnalis√©e r√©utilisable
  const patientProperties = [
    'patientId',
    'uuid',
    'identifiers',
    'person:(gender,age,birthdate,personName)',
  ];
  
  const patientSearchCustomRepresentation = `custom:(${patientProperties.join(',')})`;
  
  // Utiliser dans le hook
  const url = `${restBaseUrl}/patient?v=${patientSearchCustomRepresentation}`;
  ```

- Lors de l'utilisation de `useSWRInfinite`, envisagez de d√©finir `initialSize` en fonction de la longueur attendue des donn√©es pour optimiser le chargement initial :

  ```tsx
  const { data, setSize, size } = useSWRInfinite(getKey, fetcher, {
    keepPreviousData: true,
    initialSize: patientUuids ? Math.min(resultsToFetch, patientUuids.length) : 0,
  });
  ```

