import Image from "next/image";
import { Callout } from "nextra-theme-docs";
import { FileTree } from "nextra/components";

# Vue d'ensemble

<Callout emoji="‚ÑπÔ∏è" type="info">
  Des changements significatifs dans l'architecture de l'app shell concernant la fa√ßon dont les modules frontend sont charg√©s ont √©t√© introduits dans [Core v5](/docs/changelog). Si vous n'avez pas migr√© vos modules frontend pour tirer parti de ces nouvelles capacit√©s, suivez le [Guide de migration](/docs/migrate-to-core-v5) pour une explication d√©taill√©e de comment faire.
</Callout>

Les modules frontend sont les blocs de construction fondamentaux pour cr√©er des applications dans O3. Ce sont des morceaux de fonctionnalit√© autonomes qui peuvent √™tre charg√©s dans O3 par l'[app shell](/docs/app-shell). Par exemple, vous pourriez avoir un module frontend qui g√®re les pr√©occupations de rendu li√©es aux signes vitaux et aux biom√©triques. Ce module pourrait inclure ce qui suit:

- Une page qui affiche un aper√ßu tabulaire des signes vitaux et des biom√©triques d'un patient
- Une page qui affiche des visualisations de graphiques des signes vitaux et des biom√©triques d'un patient.
- Un formulaire qui permet √† un utilisateur d'enregistrer un nouvel ensemble de lectures de signes vitaux et de biom√©triques.
- Un en-t√™te de signes vitaux qui affiche les lectures les plus r√©centes des signes vitaux et des biom√©triques d'un patient.

Ce module frontend pourrait alors √™tre charg√© dans l'app shell et affich√© dans le dossier du patient. Les composants export√©s depuis `src/index.ts` sont enregistr√©s par l'app shell et peuvent √™tre utilis√©s dans l'application. Les modules frontend dans O3 sont g√©n√©ralement construits en utilisant React. Comme nous utilisons [single-spa](https://single-spa.js.org/) sous le capot, d'autres frameworks sont possibles, mais ils sont moins courants. Par exemple, le module frontend [Angular form engine](/docs/key-repositories#angular-form-engine) est √©crit en Angular et est un wrapper autour du [AMPATH form engine](https://ampath-forms.vercel.app/). En ce sens, l'app shell est agnostique du framework. En pratique, les fonctionnements de bas niveau de l'app shell ont √©t√© abstraits de telle mani√®re que les ing√©nieurs frontend peuvent se concentrer sur le comportement des modules plut√¥t que sur le framework.

## Concepts critiques (√† ne pas manquer)

Voici trois concepts cl√©s qu‚Äôon oublie facilement :

1. **C√¢blage de la distro (ce qui se charge r√©ellement) :** `spa-assemble-config.json` d√©finit quels modules frontend et quelles versions sont inclus dans votre distro. Ce fichier g√©n√®re l‚Äôimport map, et l‚Äôapp shell ne charge que ce que l‚Äôimport map contient. Si un module n‚Äôest pas dans l‚Äôimport map, il ne se chargera pas.
2. **Flux d‚Äôenregistrement (pourquoi pages/extensions s‚Äôaffichent) :** `src/index.ts` et `routes.json` fonctionnent ensemble. L‚Äôapp shell lit `routes.json` et les exports nomm√©s de `index.ts`, puis enregistre les pages et les extensions. S‚Äôils ne correspondent pas, rien ne s‚Äôaffiche.
3. **Tags de version (pourquoi vos changements ne sont pas visibles) :** `latest` et `next` sont diff√©rents. Votre distro ne charge que le tag indiqu√© dans `spa-assemble-config.json`.

## Mod√®le mental (comment les modules frontend fonctionnent r√©ellement)

Si vous d√©butez avec O3, voici le mod√®le mental √† garder en t√™te:

1. **Un module frontend est un package npm.** Chaque module est publi√© ind√©pendamment et poss√®de son propre `package.json`, `src/index.ts` et `routes.json`.
2. **L‚Äôapp shell d√©cide quoi charger.** Il lit l‚Äôimport map de la distribution (g√©n√©r√©e depuis `spa-assemble-config.json`) et charge les modules list√©s.
3. **Les modules d√©clarent ce qu‚Äôils fournissent √† deux endroits:**
   - **`src/index.ts`** exporte les *m√©tadonn√©es dynamiques* (pages/extensions en exports nomm√©s + logique de d√©marrage).
   - **`routes.json`** d√©clare les *m√©tadonn√©es statiques* (routes/pages, d√©pendances backend, etc.).
4. **Pages et extensions ne sont pas la m√™me chose.**
   - **Pages** = routes compl√®tes (ex. `/patient/123/vitals`).
   - **Extensions** = fragments UI branch√©s sur des *extension slots* appartenant √† d‚Äôautres modules.
5. **Les slots vivent dans l‚ÄôUI h√¥te.** Un module h√¥te expose des slots, d‚Äôautres modules y enregistrent des extensions. C‚Äôest le c≈ìur de la modularit√© d‚ÄôO3.
6. **L‚Äôimport map est la source de v√©rit√©.** Elle mappe noms de modules ‚Üí URLs et contr√¥le les versions.
7. **En dev local, on remplace l‚Äôimport map.** Devtools peut substituer une version locale sans changer `spa-assemble-config.json`.

Les modules frontend sont g√©n√©ralement organis√©s en d√©p√¥ts sp√©cifiques √† un domaine. Par exemple, les modules frontend concernant la gestion des patients existent dans le monorepo [Patient Management](https://github.com/openmrs/openmrs-esm-patient-management). Certains modules vivent dans des monorepos, d'autres dans des d√©p√¥ts autonomes, selon la port√©e. Quelle que soit l'organisation, chaque module est construit et publi√© comme un paquet npm ind√©pendant afin d'√™tre r√©f√©renc√© dans l'import map de votre distribution.

Dans cette structure, vous aurez typiquement un r√©pertoire `packages` √† la racine du monorepo. Ce r√©pertoire contient tous vos modules frontend. Par exemple, le monorepo de gestion des patients a la structure suivante:

Anatomie rapide (en un coup d'≈ìil):

- `package.json` - m√©tadonn√©es et d√©pendances du module
- `src/index.ts` - point d'entr√©e du module
- `routes.json` - m√©tadonn√©es statiques des routes (pages/extensions et leurs routes)
- `config-schema.ts` - o√π vivent les propri√©t√©s de configuration du module

<FileTree>
  <FileTree.Folder name="packages" defaultOpen>
    <FileTree.Folder name="esm-active-visits-app" />
    <FileTree.Folder name="esm-appointments-app" />
    <FileTree.Folder name="esm-outpatient-app" />
    <FileTree.Folder name="esm-patient-list-app" />
    <FileTree.Folder name="esm-patient-registration-app" />
    <FileTree.Folder name="esm-patient-search-app" defaultOpen>
      <FileTree.Folder name="src" defaultOpen>
        <FileTree.File name="config-schema.ts" />
        <FileTree.File name="declarations.d.ts" />
        <FileTree.File name="index.ts" />
        <FileTree.File name="routes.json" />
      </FileTree.Folder>
    </FileTree.Folder>
  </FileTree.Folder>
  <FileTree.File name="package.json" />
  <FileTree.File name="yarn.lock" />
</FileTree>

Chaque module frontend est un paquet npm ind√©pendant avec:

- Son propre fichier `package.json` (s√©par√© du fichier `package.json` √† la racine). Ce fichier d√©finit les d√©pendances et les m√©tadonn√©es du module.
- Un r√©pertoire `src` qui contient le code source du module. Ce r√©pertoire contient les fichiers suivants:
  - Un fichier `config-schema.ts` qui d√©finit le sch√©ma de configuration du module
  - Un fichier `declarations.d.ts` qui d√©finit les d√©clarations TypeScript du module
  - Un fichier `index.ts` qui d√©finit le point d'entr√©e du module
  - Un fichier `routes.json` qui d√©finit les m√©tadonn√©es statiques du module (routes, pages, d√©pendances backend)

Les modules frontend sont aussi appel√©s `microfrontends` dans O3. Ils ont les caract√©ristiques suivantes:

- Ils suivent la convention de nommage `esm-`, m√™me si le chargement se fait au runtime via des bundles Module Federation.
- Ils ont une partie descriptive qui indique la fonctionnalit√© du module. Par exemple, `esm-patient-search-app` g√®re la recherche de patients.
- Ils peuvent avoir un suffixe `-app` dans leur nom, mais ce n'est pas obligatoire.

## Versions des modules frontend expliqu√©es

Chaque module frontend est un package npm, g√©n√©ralement avec un nom se terminant par `-app`. Les ESM d'OpenMRS sont publi√©s avec trois
√©tiquettes diff√©rentes : "next", "latest" et un num√©ro de version. Voici ce que chaque √©tiquette signifie :

- üî¥‚ö†Ô∏èüöß **"next" = Pr√©-version, en d√©veloppement.** La plus r√©cente, √† la pointe, encore en construction. "next" se r√©f√®re toujours √† la version la plus r√©cente mais pas encore publi√©e d'un ESM (par exemple, 3.2.1-pre.1067). _Les versions √©tiquet√©es "next" ne sont pas recommand√©es pour une utilisation en production_ car elles sont consid√©r√©es comme des travaux en cours instables et n'ont souvent pas subi de tests d'int√©gration.
- üü° **"latest" = Derni√®re version publi√©e.** "latest" se r√©f√®re toujours √† la version la plus r√©cente publi√©e d'un ESM (par exemple, 3.2.0). Bien que vous puissiez utiliser la version "latest" de n'importe quel ESM, vous avez plus de contr√¥le en sp√©cifiant le num√©ro de version exact de chaque ESM que vous utilisez.
- üü¢‚úÖ **vX.X.X = Une version sp√©cifique.** Un num√©ro de version se r√©f√®re toujours √† une version sp√©cifique de chaque ESM. Par exemple, 3.2.0 ou 3.2.1-pre.1067 sont des versions sp√©cifiques de l'ESM @openmrs/esm-api, bien que cette derni√®re soit une pr√©-version.

Ces tags sont choisis dans votre `spa-assemble-config.json`, qui alimente l'import map de votre distribution.

En d‚Äôautres termes: **le tag de version choisi dans `spa-assemble-config.json` devient la version charg√©e par l‚Äôapp shell**.

Les modules frontend sont charg√©s dans l'application sur la base d'un fichier JSON sp√©cial appel√© [import map](/docs/core-concepts#import-map). L'app shell s'appuie sur cette import map (g√©n√©r√©e depuis `spa-assemble-config.json`) pour d√©cider quels modules charger. Pour plus de d√©tails sur le chargement des modules frontend, consultez les guides [App shell](/docs/app-shell) et [Module loading](/docs/frontend-modules/loading-modules).

<br />
<Image src="/o3-execution.png" alt="O3 architecture" width={600} height={600} />

Ce diagramme d√©crit ce qui se passe lorsque l'application est ex√©cut√©e. Le shell de l'application charge les fichiers de configuration, la carte d'importation sp√©cifie o√π les modules frontend sont r√©cup√©r√©s, et [charge les modules frontend](/docs/frontend-modules/loading-modules).

## Anatomie d'un module frontend

Chaque module frontend doit avoir:

- Un fichier manifeste package.json qui d√©finit les d√©pendances et les m√©tadonn√©es du module
- Un fichier src/index.ts qui d√©finit le point d'entr√©e du module
- Une fonction startupApp qui d√©finit les m√©tadonn√©es dynamiques du module
- Un fichier src/routes.json qui d√©finit les m√©tadonn√©es statiques du module

### Fichier manifeste (package.json)

Chaque module frontend a un fichier `package.json` de niveau racine qui d√©finit ses d√©pendances et ses m√©tadonn√©es. Voici un extrait du fichier `package.json` du module frontend form builder:

```json
{
  "name": "@openmrs/esm-form-builder-app",
  "version": "2.0.1",
  "license": "MPL-2.0",
  "description": "OpenMRS ESM Form Builder App",
  "browser": "dist/openmrs-esm-form-builder-app.js",
  "main": "src/index.ts",
  "source": true,
  "scripts": {
    "start": "openmrs develop",
    "serve": "webpack serve --mode=development",
    "build": "webpack --mode production",
    "analyze": "webpack --mode=production --env.analyze=true",
    "lint": "TIMING=1 eslint src --ext js,jsx,ts,tsx",
    "prettier": "prettier --write 'src/**/*.{ts,tsx}'",
    "typescript": "tsc",
    "test": "jest --config jest.config.js",
    "test-e2e": "playwright test",
    "verify": "turbo lint typescript coverage",
    "coverage": "yarn test --coverage --passWithNoTests",
    "postinstall": "husky install",
    "extract-translations": "i18next 'src/**/*.component.tsx' --config ./i18next-parser.config.js",
    "ci:bump-form-engine-lib": "yarn up @openmrs/openmrs-form-engine-lib@next"
  }
}
```

Voici quelques √©l√©ments cl√©s √† retenir de l'examen de ce fichier:

- La propri√©t√© `name` qui d√©finit le nom du module. Cette propri√©t√© est utilis√©e comme identifiant unique du module dans la [import map](/docs/core-concepts#import-map).
- La propri√©t√© `browser` qui pointe vers le point d'entr√©e du bundle construit (ce que l'app shell charge au runtime).
- La propri√©t√© `main` qui d√©finit le [point d'entr√©e](#the-application-entry-point-indexts) du code source du module frontend, qui est typiquement `src/index.ts`.

### Le point d'entr√©e de l'application (`index.ts`)

Les modules frontend d√©finissent leur point d'entr√©e dans `src/index.ts`.

```ts
import { defineConfigSchema, getSyncLifecycle, registerBreadcrumbs } from "@openmrs/esm-framework";
import { configSchema } from "./config-schema";
import rootComponent from "./root.component";
import systemAdministrationFormBuilderCardLinkComponent from "./form-builder-admin-card-link.component";

const moduleName = "@openmrs/esm-form-builder-app";

const options = {
  featureName: "form-builder",
  moduleName,
};

export const importTranslation = require.context("../translations", true, /.json$/, "lazy");

export function startupApp() {
  defineConfigSchema(moduleName, configSchema);

  registerBreadcrumbs([
    {
      path: `${window.spaBase}/form-builder`,
      title: "Form Builder",
      parent: `${window.spaBase}/home`,
    },
    {
      path: `${window.spaBase}/form-builder/new`,
      title: "Form Editor",
      parent: `${window.spaBase}/form-builder`,
    },
    {
      path: `${window.spaBase}/form-builder/edit/:uuid`,
      title: "Form Editor",
      parent: `${window.spaBase}/form-builder`,
    },
  ]);
}

export const root = getSyncLifecycle(rootComponent, options);

export const systemAdministrationFormBuilderCardLink = getSyncLifecycle(
  (systemAdministrationFormBuilderCardLinkComponent),
  options
);
```

Ce fichier est le point d'entr√©e du module frontend. C'est le premier fichier qui est ex√©cut√© lorsque le module frontend est charg√©. Il est responsable de la mise en place du module frontend et de l'exportation de la configuration du module. Plus pr√©cis√©ment, dans cet exemple:

- Il exporte une fonction `importTranslation` qui est utilis√©e pour charger les traductions du module.
- Il exporte √©galement deux exportations nomm√©es, `root` et `systemAdministrationFormBuilderCardLink`. Ce sont des exportations nomm√©es pour une page et une extension, respectivement. Elles sont utilis√©es pour indiquer au shell de l'application comment charger le contenu du module frontend.
- Il exporte √©galement une fonction `startupApp` qui est utilis√©e pour configurer le module frontend. Dans ce cas, le sch√©ma de configuration du module frontend est d√©fini ici, ainsi que les fils d'Ariane du module.

#### La fonction `startupApp` (d√©marrage)

Chaque module frontend d√©finit une fonction nomm√©e `startupApp`. Cette fonction effectue toute configuration qui doit √™tre effectu√©e au moment o√π le module est charg√©. La fonction startupApp est l'endroit o√π:

- d√©finir le sch√©ma de configuration
- enregistrer les breadcrumbs
- relier les m√©tadonn√©es dynamiques (exports) aux m√©tadonn√©es statiques de `routes.json`

#### La fonction `importTranslation`

Elle est n√©cessaire pour que les traductions fonctionnent. Elle indique √† l'application frontale comment charger les cha√Ænes de traduction. Notez que le premier argument de `require.context` est un r√©pertoire, `../translations`. Ce r√©pertoire doit exister √† cet endroit par rapport au fichier `index.ts`.

### M√©tadonn√©es statiques dans `routes.json`

Le fichier `routes.json` est utilis√© pour configurer les m√©tadonn√©es statiques du module frontend. Celles-ci incluent:

- Les `extensions` que le module frontend fournit
- Les `pages` que le module frontend fournit
- Les d√©pendances `backend` que le module frontend requiert. C'est un objet qui indique √† l'application frontend quels sont les modules du serveur OpenMRS dont le module frontend d√©pend, et de quelles versions. Si ces d√©pendances ne sont pas respect√©es, les administrateurs seront alert√©s

La structure de ce fichier statique est dict√©e par le standard OpenMRS Routes [JSON schema](https://json.openmrs.org/routes.schema.json).

### Extensions et extension slots (comment les modules s‚Äôassemblent)

L‚ÄôUI d‚ÄôO3 se compose en *branchant des extensions dans des slots*. Voici le flux:

1. **Un module h√¥te d√©clare un extension slot** dans son UI (par exemple, un slot pour les widgets du dossier patient).
2. **D‚Äôautres modules enregistrent des extensions** pour ce slot (par exemple, un widget ‚ÄúSignes vitaux‚Äù).
3. **L‚Äôapp shell r√©sout et rend** les extensions dans les slots au runtime.

Cela permet d‚Äôajouter, retirer ou remplacer des fragments UI sans modifier le module h√¥te. C‚Äôest l‚Äôun des piliers de la modularit√© d‚ÄôO3.

Les extensions peuvent aussi √™tre activ√©es, d√©sactiv√©es et configur√©es via le [guide du syst√®me de configuration](/docs/configuration-system).

### Du code √† l‚Äô√©cran (cycle complet)

Voici le cycle complet, √©tape par √©tape:

1. **Vous construisez et publiez** un module sur npm.
2. **Vous l‚Äôajoutez √† `spa-assemble-config.json`** (ou mettez √† jour son tag).
3. **La distribution g√©n√®re une import map** depuis `spa-assemble-config.json`.
4. **L‚Äôapp shell charge l‚Äôimport map** au runtime.
5. **L‚Äôapp shell charge votre module** via l‚ÄôURL de l‚Äôimport map.
6. **Votre `startupApp` s‚Äôex√©cute**, en enregistrant pages/extensions et sch√©mas de config.
7. **Les routes se r√©solvent** (pages) et **les slots se remplissent** (extensions).

Si votre module n‚Äôappara√Æt pas, l‚Äô√©chec se trouve presque toujours dans l‚Äôune de ces √©tapes.

### D√©pannage quand un module n‚Äôappara√Æt pas

Utilisez cette checklist pour localiser rapidement le probl√®me:

1. **Le module est-il dans l‚Äôimport map ?**  
   Ouvrez `/openmrs/spa/importmap.json` et confirmez que le nom du module existe et pointe vers la bonne URL.
2. **L‚ÄôURL est-elle accessible ?**  
   Ouvrez l‚ÄôURL de l‚Äôimport map dans le navigateur. Vous devez voir un bundle JS, pas une page HTML/404.
3. **Le module exporte-t-il ce que l‚Äôapp shell attend ?**  
   V√©rifiez que `src/index.ts` exporte les pages/extensions nomm√©es d√©clar√©es dans `routes.json`.
4. **Les noms de route correspondent-ils aux exports ?**  
   Si `routes.json` d√©clare un composant `"root"`, `index.ts` doit exporter `root`.
5. **Visez-vous le bon extension slot ?**  
   Le nom du slot dans votre extension doit correspondre exactement au slot expos√© par l‚ÄôUI h√¥te.
6. **Y a‚Äët‚Äëil un override d‚Äôimport map en dev ?**  
   V√©rifiez Devtools et localStorage. Un override obsol√®te peut masquer vos changements.

## Concepts cl√©s (√† conna√Ætre t√¥t)

Si vous construisez ou d√©pannez des modules, ces notions vous feront gagner du temps:

- **Sch√©ma de configuration** ‚Äì `config-schema.ts` d√©finit les options configurables du module. L‚Äôapp shell charge et fusionne la config au runtime, ce qui contr√¥le le comportement c√¥t√© impl√©mentation. Voir le [guide du syst√®me de configuration](/docs/configuration-system).
- **Traductions** ‚Äì Les modules fournissent les traductions via `importTranslation` dans `src/index.ts`, g√©n√©ralement √† partir d‚Äôun dossier `translations/`. Si c‚Äôest absent ou mal configur√©, la localisation ne fonctionne pas.
- **Lifecycles sync vs async** ‚Äì `getSyncLifecycle` embarque le code dans le bundle principal, tandis que `getAsyncLifecycle` charge √† la demande. Utilisez‚Äëles selon les besoins de performance. Voir [Tests unitaires et d‚Äôint√©gration](/docs/frontend-modules/unit-and-integration-testing) et les notes de performance dans [Conventions de codage](/docs/coding-conventions/performance).
- **D√©pendances backend** ‚Äì `routes.json` peut d√©clarer des d√©pendances et versions de modules backend. Si elles ne sont pas satisfaites, O3 alerte les administrateurs.
- **Overrides Devtools** ‚Äì Le dev local repose souvent sur les overrides de l‚Äôimport map. Voir [D√©veloppement](/docs/frontend-modules/development#import-map-overrides).
- **Strat√©gie de version** ‚Äì `latest` est la derni√®re version stable, `next` est une pr√©‚Äëversion. √âpinglez des versions en production, utilisez `next` pour tester.
